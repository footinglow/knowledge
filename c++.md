# C++
・C++は、C言語にオブジェクト指向を取り入れて拡張した言語
・1998年にC++11(C++0x)、C++14、C++17と3年周期で、言語機能と標準ライブラリが拡張されている。
・モダン言語の良い機能を取り入れている
・C言語で記述したプログラムをほとんどそのまま、C++言語でもコンパイル、実行できるため過去資産の流用や、低レベルのプログラミングにも対応している。
・歴史があるため、同じことをするのに、低レベルから高レベルの記述まで存在する。
・使用するライブラリやコンパイラが対応しているC++のバージョンに合わせて実装する必要がある

# 思うこと
・C言語を拡張しているため、構造体を含む変数に対するイコール(=)はコピーを意味する
・Java、C#、Pythonなどの近代言語では、オブジェクトに対するイコール(=)は参照のみをコピーするが、C++ではオブジェクトの実態をコピーする
・そのため関数で生成したオブジェクトをreturnで受け取る場合にイコールを使用すると、近代言語では参照のみのコピーに対して、C++では実体のコピーとなり、オブジェクトサイズが大きい場合は処理時間がかかり、また一時的にメモリも必要となる。
・その対策として導入されたのが、右辺値(左辺値の概念もこの時生まれた？）、右辺値参照、ムーブ、完全転送の概念と操作方法であり、そのために左辺値と右辺値を共通に扱うためにユニバーサル参照（C++17で転送参照:forwarding referenceという名称に定めた)の手法が誕生した。
・

# C++の絵本 C++が好きになる新しい9つの扉
P11 クラスの中で中身を定義した関数をインライン関数といいます(inline修飾子を使わなくても）
P20 【C++11】クラスを定義するときに、メンバ変数の初期値を設定可能
P41　defineの代わりにconstを使用できる。型を指定できるため、defineよりも厳密に値を定義できる
P41　配列のサイズを定義するときにdefineではなく、constが使える。
  const int BUFSIZE = 10;
  int b[BUFSIZE];  //C言語ではコンパイルエラー
P43　const指定したポインタをconstしていないポインタに代入しようとするとコンパイルエラーになる。代入できてしまうと、代入したポインタから変更できてしまうため
P44　【C++14】2進数リテラル　0b111000001111
P44　文字列リテラル　u8""：UTF-8　u""：UTF-16 U""：UTF-32
P45　【C++11】char16_t：UTF-16文字用の型、char32_t：utf-32文字用の型
P45　【C++11】エスケープ文字を無視する文字リテラル
　　　"C:\\aaa.txt"
    R"C:\aaa.txt"

　　　参考：wchar_tはワイド文字。
P47　【C++11】enum classを使うと、{}内の定義名が、他のenum classの定義名と重複することができるようになった
　　enum class Colors {Red, Green, Yellow}  //
    Colors bookcolor;                       //　C++の場合、「enum」は不要
    bookcolor = Colors::Red;                //　クラス名が必要

P52　ディフォルト引数は最後の引数から順に設定していく必要がある
　　　呼び出し時は、ある引数を省略すると、その引数以降はすべて省略する。
P55　戻り値のみが異なるオーバーロードはできない
P59　書式の設定　
P63　スコープ解決演算子で「::name」はグローバル変数nameを表す
P67　インライン関数はinlineで修飾した関数で、ヘッダファイルに定義する
P77 引数をconst参照にすると、実体渡しのように安全でかつ、大きなデータをポインタ渡しのように高速にデータを渡すことができる
P78　関数に引数は「値渡し」「アドレス渡し」「参照渡し」があるが、値渡しと参照渡しが呼び出し方が同じため、引数の値が関数内で変更されるかわからないという問題がある
　　★関数の中で引数の値を変更する場合は、「アドレス渡し」にするとよいでしょう。
P82　引数がintとポインタでオーバーロードしている場合、NULLを使用すると、ポインタではなくint側の0と認識されるため、期待と異なる関数が呼ばれる場合がある
　　　【C++11】nullptrを使用すると、ポインタと認識されるため、この問題を回避できる
P91　int *p=new int[10]のように確保した配列用メモリは、delete [] p;と書いて開放する。[]が忘れやすいので注意する
P94　コピーコンストラクタ
　　　Person　psn1:
   　 Person　psn2(psn1);　//コピーコンストラクタが呼ばれる

      Person psn3;
      psn3 = psn1;        // operator=()が呼ばれる
P95　クラス定義で、Person(const Person &psn); がコピーコンストラクタ
P95　【c++11】クラス定義で、Person(const Person &psn) = delete;と記述すると、ディフォルトのコピーコンストラクタを使用禁止にできる
P100　friendを使うと、privateメンバーを他のクラスからアクセスできるようになる
　　　クラスレベルと特定の関数を指定することもできる

# コンストラクタ
・コンストラクタのエラーを唯一伝える方法が例外のみ


# 関数の入出力について
・関数への入力は、引数で実体渡しもしくはconstの参照渡しにする
・関数から出力は、なるべく実態をreturnで返す
・関数からの出力を引数にする場合はポインタ渡しとする


# 参考
・
・
